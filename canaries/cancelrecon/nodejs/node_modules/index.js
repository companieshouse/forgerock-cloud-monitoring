var synthetics = require('Synthetics');
const log = require('SyntheticsLogger');

const runStuckReconsCheck = async function () {

    let accessToken;
    const { FIDC_URL, USER, PASSWORD, ADMIN_CLIENT, ADMIN_CLIENT_SECRET, CANCEL_RECON_AFTER } = process.env

    const validateAccessToken = async function (res) {
        return new Promise((resolve, reject) => {
            if (res.statusCode < 200 || res.statusCode > 299) {
                throw res.statusCode + ' ' + res.statusMessage;
            }

            let responseBody = '';
            res.on('data', (d) => {
                responseBody += d;
            });

            res.on('end', () => {
                // Add validation on 'responseBody' here if required.
                accessToken = JSON.parse(responseBody).access_token;
                if(accessToken && accessToken.length > 0){
                    resolve();
                } else {
                    reject();
                }
            });
        });
    };

    const validateReconDuration = async function (res) {
        return new Promise((resolve, reject) => {
            if (res.statusCode < 200 || res.statusCode > 299) {
                throw res.statusCode + ' ' + res.statusMessage;
            }

            let responseBody = '';
            res.on('data', (d) => {
                responseBody += d;
            });

            res.on('end', async () => {
                const activeReconsData = JSON.parse(responseBody).reconciliations.filter(recon => recon.state === 'ACTIVE' )

                await Promise.all(activeReconsData.map(async (activeRecon) => {
                    log.info(`Active Reconciliation : ${JSON.stringify(activeRecon)}`)
                    if (activeRecon && activeRecon.state === 'ACTIVE' && activeRecon.duration > `${CANCEL_RECON_AFTER}`) {
                        log.info(`Stuck Reconciliation found : ${activeRecon.mapping} - _id: ${activeRecon._id} - stage: ${activeRecon.stage}`)
                        // Cancel Mappings Recon
                        let cancelRecon = {
                            hostname: FIDC_URL.replace('https://', ''),
                            method: 'GET',
                            path: "/openidm/recon/" + activeRecon._id + "?_action=cancel",
                            port: '443',
                            protocol: 'https:',
                            body: "",
                            headers: { "Content-Type": "application/json", "Authorization": `Bearer ${accessToken}` }
                        };
                        cancelRecon['headers']['User-Agent'] = [synthetics.getCanaryUserAgentString(), cancelRecon['headers']['User-Agent']].join(' ');

                        // // Mark Mappings Recon as cancelled
                        // let markAsCancelled = {
                        //     hostname: FIDC_URL.replace('https://', ''),
                        //     method: 'GET',
                        //     path: "/openidm/recon/" + mappingWithRecon.recon.id + "?_action=markCanceled",
                        //     port: '443',
                        //     protocol: 'https:',
                        //     body: "",
                        //     headers: { "Content-Type": "application/json", "Authorization": `Bearer ${accessToken}` }
                        // };
                        // markAsCancelled['headers']['User-Agent'] = [synthetics.getCanaryUserAgentString(), markAsCancelled['headers']['User-Agent']].join(' ');
                    
                        // Set step config option for Cancel Mappings Recon
                        let configReconDuration = {
                            includeRequestHeaders: false,
                            includeResponseHeaders: false,
                            includeRequestBody: false,
                            includeResponseBody: false,
                            restrictedHeaders: [],
                            continueOnHttpStepFailure: true
                        };
                        return await synthetics.executeHttpStep(`Cancel overrunning recon for mapping ${activeRecon.mapping}`, fetchAllRecons, validateReconDuration, configReconDuration);
                    }
                }))

                resolve(`finished`)
            });
        });
    };

    // Set request option for Get Access Token
    const pw = `${PASSWORD}`
    const encodedPassword = encodeURIComponent(pw)
    const clientSecret = `${ADMIN_CLIENT_SECRET}`
    const encodedClientSecret = encodeURIComponent(clientSecret)

    let requestAccessToken = {
        hostname: FIDC_URL.replace('https://', ''),
        method: 'POST',
        path: '/am/oauth2/realms/root/realms/alpha/access_token?auth_chain=PasswordGrant',
        port: '443',
        protocol: 'https:',
        body: `grant_type=password&username=${USER}&password=${encodedPassword}&scope=fr:idm:*&client_id=${ADMIN_CLIENT}&client_secret=${encodedClientSecret}`,
        headers: { "Content-Type": "application/x-www-form-urlencoded" }
    };
    requestAccessToken['headers']['User-Agent'] = [synthetics.getCanaryUserAgentString(), requestAccessToken['headers']['User-Agent']].join(' ');

    // Set step config option for Get Access Token
    let configPayload = {
        includeRequestHeaders: false,
        includeResponseHeaders: false,
        includeRequestBody: false,
        includeResponseBody: false,
        restrictedHeaders: [],
        continueOnHttpStepFailure: true
    };

    await synthetics.executeHttpStep('Get Access Token', requestAccessToken, validateAccessToken, configPayload);

    //const mappings = MONITORED_COMPONENT.split(',');
    
    // Set request option for Verify Mappings Recon
    let fetchAllRecons = {
        hostname: FIDC_URL.replace('https://', ''),
        method: 'GET',
        path: `/openidm/recon`,
        port: '443',
        protocol: 'https:',
        body: "",
        headers: { "Content-Type": "application/json", "Authorization": `Bearer ${accessToken}` }
    };
    fetchAllRecons['headers']['User-Agent'] = [synthetics.getCanaryUserAgentString(), fetchAllRecons['headers']['User-Agent']].join(' ');

    return await synthetics.executeHttpStep(`Fetch all recons`, fetchAllRecons, validateReconDuration, configPayload);

};

exports.handler = async () => {
    return await runStuckReconsCheck();
};